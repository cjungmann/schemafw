@node SelectX SQL Changes Checklist
@subsection SelectX SQL Changes Checklist

After generating the @emph{sql} and @emph{srm} files on the previous
page, there remains several customization steps to follow for making
a working @emph{selectx} widget.

The steps in this checklist assume that the relationship between the
@emph{item} and @emph{option} tables is maintained by a @emph{map}
table, using the tables defined in the last section, @emph{Item},
@emph{Keyword}, and @emph{Keyword2Item}.  A simpler alternative, saving
the comma-separated list of integers in a text or large varchar field,
will be left to your imagination.

The scenario also uses the merged document construction, where lookup
results are included the main page to be used by the main page as well
as the subordinate interactions.

@menu
* SelectX SQL CSV Integer Parsing Procedure ::
* SelectX SQL Common Record-View Query ::
* SelectX SQL Update List Procedure ::
* SelectX SQL Update Read and Value Procedures ::
* SelectX SQL Add Procedure Modifications ::
* SelectX SQL Update Procedure Modifications ::
* SelectX SQL Delete Procedure Modifications ::
@end menu


@node SelectX SQL CSV Integer Parsing Procedure
@subsubsection SelectX SQL CSV Integer Parsing Procedure

When adding or editing records, the keyword selections will be
posted as an CSV list of integers.  The Add and Update procedures
need to convert this list.  The procedure in the section provides
this service.

The framework includes a utility procedure, @code{ssys_make_SFW_IntTable_from_list},
that aids in this process.  The utility procedure creates a temporary
table named @code{SFW_IntTable}, includes integer fields @emph{val}
for the integer values, and @emph{pos} to preserve the position of the
value in the list.  This temporary table can be used to join the matching
@emph{option} records to the current @emph{item} record.

@verbatim
CREATE PROCEDURE App_Item_Keywords_Assign(id_item INT UNSIGNED,
                                          keywords TEXT)
BEGIN
   -- Use backticks around field name id_item to distinguish
   -- it from the parameter with the same name:
   DELETE FROM Keyword2Item
     WHERE `id_item` = id_item;

   IF keywords IS NOT NULL AND LENGTH(keywords) > 0 THEN
      CALL ssys_make_SFW_IntTable_from_list(keywords);
      INSERT INTO Keyword2Item (id_item, id_keyword, position)
         SELECT id_item, val, pos
           FROM SFW_IntTable;

      DROP TABLE SFW_IntTable;
   END IF;
END $$
@end verbatim

@node SelectX SQL Common Record-View Query
@subsubsection SelectX SQL Common Record-View Query

The List, Value, and Read procedures are typically very similar,
and require similar modifications to properly include the linked
records.  The example below is from the List procedure, and the
WHERE clause would be modified in the Read and Value procedures.

@example
SELECT i.id,
       i.name,
       GROUP_CONCAT(DISTINCT k.id_keyword ORDER BY k.position) AS klist
  FROM Item i
       LEFT JOIN Keyword2Item k ON k.id_item = i.id
 WHERE id IS NULL OR a.id = id
 GROUP BY i.id;
@end example

Note the following customizations:

@table @strong
@item GROUP_CONCAT function
The @emph{klist} field, a non-native field that doesn't exist in the
@emph{Item} table), is generated by the GROUP_CONCAT function.

@item LEFT JOIN
We use LEFT JOIN to join the @emph{Item} and @emph{Keyword} tables
to ensure that items with no keywords will not be ignored, as would
happen if we use INNER JOIN.

@item GROUP BY
This clause groups keywords by item, preparing the intermediate
result for the GROUP_CONCAT function.
@end table


@node SelectX SQL Update List Procedure
@subsubsection SelectX SQL Update List Procedure

The List procedure is usually the page from which all interactions
originate, and is thus responsible for loading the lookup tables
that the merged subordinate interactions will use to populate their
forms.

The following example shows the main query, modified as explained in
the previous section, and the following SELECT statement that creates
the lookup result that will be used to translate the @emph{klist} field
here and in merged form interactions.

@example
CREATE PROCEDURE App_Item_List(INT id)
BEGIN
   SELECT i.id,
          i.name,
          GROUP_CONCAT(DISTINCT k.id_keyword ORDER BY k.position) AS klist
     FROM Item i
          LEFT JOIN Keyword2Item k ON k.id_item = i.id
    WHERE id IS NULL OR a.id = id
    GROUP BY i.id;

   SELECT * FROM Keyword;
END $$
@end example

@node SelectX SQL Update Read and Value Procedures
@subsubsection SelectX SQL Update Read and Value Procedures

In this example, for both Read and Value procedures, simply include
the Common Record-View Query, with the single modification to the
WHERE clause, where it will be sufficient to simply test for
@code{i.id = id}.

In most cases, the Read and Value procedures are identical, though
their purposes are somewhat distinct.  The Read procedure stands alone
as a source for a uneditable view of the record, while the Value
procedure is meant to provide values for a form that will be submitted
to the Update procedure.  A unique requirement for the Value procedure
is that the field names it writes must match the parameter names
of the Update procedure.

@node SelectX SQL Add Procedure Modifications
@subsubsection SelectX SQL Add Procedure Modifications

The Add procedure is the first that uses the integer parsing procedure
we created in the @ref{SelectX SQL CSV Integer Parsing Procedure}.

There are two main changes to the standard Add procedure:
@enumerate
@item Additional parameter (klist) in which the keyword list is received

@item Call the procedure we previously made to parse and integrate
      keywords (App_Item_Keywords_Assign).  Note that this procedure
      is only called if the Item record was successfully added.
@end enumerate

Here is a listing of the modified Add procedure:

@example
   CREATE PROCEDURE App_Item_Add(name VARCHAR(20),
                                 klist TEXT)
   BEGIN
      DECLARE newid INT UNSIGNED;
      DECLARE rcount INT UNSIGNED;

      INSERT INTO Item (name)
             VALUES (name);

      SELECT ROW_COUNT() INTO rcount;
      IF rcount > 0; THEN
         SELECT LAST_INSERT_ID() INTO newid;
         CALL App_Item_Keywords_Assign(newid, klist);

         -- Return new record
         CALL App_Item_List(newid);
      END IF;
   END $$
@end example

@node SelectX SQL Update Procedure Modifications
@subsubsection SelectX SQL Update Procedure Modifications

Like the Add procedure on the previous page, the Update procedure
uses the @ref{SelectX SQL CSV Integer Parsing Procedure} we made
previously. The following modifications are made:

@enumerate
@item Additional parameter (klist) in which the keyword list is received

@item Make update klist update and the call to App_Item_List
      unconditional.  Since the @emph{klist} field is non-native,
      it's possible that an unchanged Item record would return a
      ROW_COUNT() value of 0, even though the keyword list may have
      changed.

@item Update the Keyword mapping with the App_Item_Keywords_Assign
      procedure.
@end enumerate

The resulting procedure looks like this:

@example
CREATE PROCEDURE App_Item_Update(id INT UNSIGNED,
                                 name VARCHAR(20),
                                 klist TEXT)
BEGIN
   UPDATE Item
      SET `name` = name
    WHERE `id` = id;

   CALL App_Item_Keywords_Assign(id, klist);

   CALL App_Item_List(id);
END $$
@end example


@node SelectX SQL Delete Procedure Modifications
@subsubsection SelectX SQL Delete Procedure Modifications

Because the Item may keywords associated with it, the Delete procedure
must include a query to remove them.

I recommend removing the mapping first to prevent a momentary set of
orphaned keywords.  This would be necessary if the Keyword2Item table
includes foreign key restraints, but is a good practice even without
constraints.

@example
CREATE PROCEDURE App_Item_Delete(id INT UNSIGNED)
BEGIN
   DELETE FROM Keyword2Item
    WHERE id_item = id;

   DELETE FROM Item
    WHERE `id` = id;

   -- This query signals the deletion success.
   SELECT ROW_COUNT() AS deleted;
END $$
@end example                                 
