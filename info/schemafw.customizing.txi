@node Customizing
@chapter Customizing

The fundamental philosophy of the Schema Framework is that simple things
should be automatic, but that there must be an easy way to add custom 
elements and objects to a project.  This chapter will describe the basic
steps of adding new items to the framework.

@menu
* Introduction to Customization::
* Simple Custom XSLT Template::    Create a simple custom input
* Simple Custom Javascript Class:: Animate the custom input
@end menu

@node Introduction to Customization
@section Introduction to Customization

There are usually two parts of a customization,

@enumerate
@item Add a template that will be called when your custom item
      should be rendered
@item Add a class that will instantiated to handle an action
      that occurs on the rendered custom object.
@end enumerate

@node Simple Custom XSLT Template
@section Simple Custom XSLT Template

The Schema Framework page and page components are mostly
rendered by XSLT templates.  In order to create a custom
display, it is necessary to create a template that will be
called when appropriate.  There are several factors to consider:

@table @strong
@item mode attribute
The template should include a @code{mode} attribute that is called
in the context where your custom control should be added.
@item match attribute
The match attribute of the template should include a predicate
that uniquely recognizes the element from which the custom
element will be rendered.
@item template position
Within the stylesheet, the custom template must come after any
other templates that would otherwise be matched.  When looking for
a matching template to apply, the XSLT processor uses the last
template that matches the element that is applied.  Because of
this, generic and fallback templates should come before more
specific matches.
@item data-sfw-class
The main element (ie the table, input, etc) must include the
@code{data-sfw-class} attribute set to the class name.  This
attribute allows the framework to identify that this is an
element with an operating class, and the object will not be
invoked without this attribute.
@item data-sfw-input
This attribute must be included if the object is expected to
be included within another framework object.  Normally, the
framework scans ancestors of the target of an event until it
finds the highest element with the @code{data-sfw-class} attribute,
making the object defined by that element the controlling object.
Identifying the element as a @code{data-sfw-input} element
terminates the search, returning the object defined by the
input element.
@item tabindex
This is optional, but recommended for input items.  Setting this
attribute allows the user to access the element by tabbing to it
from nearby elements.
@end table

Here is an example of a custom form control.  Notice how the
template includes a very specific match attribute and the mode
attribute @emph{construct_input}, which is called from a template
with mode='construct_input_row' in the @file{sfw_form.xsl} file.

@example
<xsl:template match="field[@@type='fancy_show']" mode="construct_input">
   <xsl:param name="data" />

   <div
      data-sfw-class="fancy_show"
      data-sfw-input="true"
      style="height:2em; width:20em; border:solid 1px black;"
      tabindex="0">
      Look at the fancy show!
   </div>
</xsl:template>
@end example

This very basic template can written directly in the @file{default.xsl}
stylesheet, or written in its own stylesheet file.  In both cases the
template must follow other templates that would otherwise match the
element.

@node Simple Custom Javascript Class
@section Simple Custom Javascript Class

Custom classes should inherit from base classes in the framework in order
to ensure basic methods are implemented.  The framework derives functions
by copying the prototype array from a base class, so the order of class
definition is important.  A base class must be defined before a subclass
can be defined.

The @code{_init()} function is enclosed in parenthesis to create an
automatically executing function with a closure scope that allows a
name for the @code{setTimeout} function but keeps the function name
out of the global scope so it isn't necessary to come up with unique
function names.

Since it's an auto executing function, it isn't necessary to tell
the framework to execute it, it will run just by being included
with the rest of the scripts.  The synchronization code within the
closure ensures that prerequisites are defined before defining the
new class.

@example
(function _init()
 @{
    // Constants to insert into initialization functions:
    var file_name="fancy_show", base_class_name="iclass", class_name="sublines";
    
    // If base class not defined, quit _init() after setting
    // up to try again in a tenth of a second:
    if ((!("SFW" in window) && setTimeout(_init,100))
        || SFW.delay_init(file_name,_init,base_class_name))
       return;

    // Copy base class prototype methods into this class's
    // prototype before adding or replacing them with the
    // prototype definitions that follow the constructor:
    if (!SFW.derive(_fancy_show, class_name, base_class_name))
       return;

    function _fancy_show(actors)
    @{
       // Consider which base class constructors must be called:
       SFW.base.call(this.actors);
    @}

    _sublines.prototype.process = function(e,t)
    @{
       // Allow base class to process generic buttons:
       if (!SFW.base.prototype.process.call(this,e,t))
          return false;

       if (e.type="click")
          SFW.alert("You clicked me, you cad!");

       return true;
    @};
 @}
)();
@end example
