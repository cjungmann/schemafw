/**
 * @page MySQL_Procedures_Main_Page MySQL for SchemaFW
 *
 * MySQL stored procedures are the foundation of SchemaFW.  Everything is
 * defined by providing values for procedure parameters or interpreting
 * the query results coming out of a stored procedure.
 *
 * The framework is designed to make it trivial to run stored procedures.
 * Hopefully, a SchemaFW developer will never miss using ad hoc queries.
 * In return, using stored procedures provides **protection against SQL
 * injection attacks**,  some **compile-time error-checking**,
 *
 * Topics covered here:
 * - @MySQL_Procedures_Overview
 *
 */

/**
 * @page MySQL_Procedures_Overview Procdures Overview
 *
 * In SchemaFW, the procedures are the application.  Virtually all
 * of an applications logic is contained in stored procedures, the
 * framework provides an interface for passing data to and acting or
 * displaying output from the procedures.
 *
 * There are a few categories of procedures.  These categories map to SchemaFW
 * response mode types:
 * - A __table procedure__ returns a set of data for display.
     @ref MySQL_Procedures_Table
 * - A __delete procedure__ deletes a conceptual record, which may require other
 *   operations (deletes or updates) to maintain data integrity.
 *   @ref MySQL_Procedures_Delete
 * - A __form procedure__ works with an item.  There are several form procedure types
 *   - An __form-edit procedure__ returns a result with a single record and information
 *     for constructing a form (a schema).
 *   - A __form-submit procedure__ accepts the information submitted from the
 *     _edit-form_ procedure and takes action based on the information.  Generally,
 *     this means updating records in the database, but it is not limited to that role.
 *     This procedure should return the updated record in a form compatible with the
 *     table view from which the edit request was generated.
 *   - A __form-new procedure__ inserts a record into the database.  The procedure
 *     serves two roles in this case.  First, the parameters of the procedure are used
 *     to generate the schema from which the form will be constructed.  The procedure
 *     is also executed with the data from the form to create a new record.  This
 *     procedure should return the new record in a form compatible with the table
 *     view to which the new record will be added.
 *   - A __form-try procedure__ is a hybrid of _form-new_ and _form-submit_ mainly
 *     intended for login forms.  It's purpose is to provide failure feedback of a
 *     previous attempt to help a user fix the input for subsequent submissions.
 *     The _form-try_ procedure is unique in that it includes data as javascript
 *     variables rather than expecting to get the data from the XML source document.
 *     See @ref MySQL_Procedures_Login_Discussion.
 *
 * - Information procedures: 
 */


/**
 * @page MySQL_Procedures_Login_Discussion Problems with Login Forms
 *
 * The SchemaFW returns XML documents that are transformed on the client to
 * usable HTML.  After a page is transformed, the framework requests the XML
 * document a second time in order to make use of the data contained in the
 * XML.  Ideally, page views will be acquired with a GET request that will
 * be cached on the client and thus avoid extra network traffic.
 *
 * In general, POST requests come from forms that have been generated by and
 * contained within page views.  This is critical because a second POST request,
 * which will be attempted by a page view, will likely return data unrelated to
 * the page view, and may well corrupt the data.  This is because the second
 * POST request will not include the posted data, so the procedure will be called
 * with null values in the parameters.
 *
 * The _form-try_ response mode was designed to provide a solution to this problem.
 * A _form-try_ procedure should have instructions to render the result as Javascript
 * variables that can be consulted after the page is rendered.  Pages of this type
 * will not attempt to get a copy of the XML data.
 *
 * The primary benficiary of the _form-try_ response mode is a login form.  If a
 * response page is generated from a login attempt, the page will attempt to get a
 * cached copy with a GET call to the same response mode.  The second attempt will
 * be without parameters, likely resulting a denied authorization, even if the
 * initial submission had resulted in an authorization.
 */

/**
 * @page MySQL_Procedures_Table The Table Procedure
 *
 * My standard practice is to write a single procedure that is used
 * both to generate an entire table and to retrieve a single line.
 * This practice ensures that the same fields will be used when the
 * procedure is called from a _form-submit_ mode.
 *
 * ~~~{.sql}
 DROP PROCEDURE IF EXISTS App_Person_List $$
 CREATE PROCEDURE App_Person_List(id INT UNSIGNED DEFAULT NULL)
 BEGIN
    SELECT p.id, p.fname, p.lname
      FROM Person p
     WHERE id IS NULL
        OR p.id = id;
 END $$
 * ~~~
 *
 * @sa Specs_Mode_Form_Submit
 */

/**
 * @page MySQL_Procedures_Delete The Delete Procedure
 *
 * A delete procedure can be pretty straight-forward.  However, an additional SELECT
 * query should be performed to inform the client about the success or failure to
 * delete.
 ~~~{.sql}
 DROP PROCEDURE IF EXISTS App_Person_Delete $$
 CREATE PROCEDURE App_Person_Delete(id INT UNSIGNED)
 BEGIN
    DELETE
      FROM Person
     WHERE Person.id = id;

    -- Inform client about success or failure:
    SELECT ROW_COUNT() AS deleted;
 END $$
 ~~~
 *
 * When the delete command comes from an edit form associated with a line in the
 * table AND in the XML document, letting the client know that the delete succeeded
 * allows the framework to delete the record from the table and the XML document.
 */

/**
 * @page MySQL_Procedures_Form_Submit Procedure for form-submit
 *
 * Refer to @ref MySQL_Procedures_Table for an explanation of how
 * the line `CALL App_Person_List(id)` works.
 *
 * ~~~{.sql}
 * DROP PROCEDURE IF EXISTS App_Person_Submit $$
 * CREATE PROCEDURE App_Person_Submit(id INT UNSIGNED,
 *                                    fname VARCHAR(20),
 *                                    lname VARCHAR(20))
 * BEGIN
 *   DECLARE rows_updated INT UNSIGNED;    
 *   UPDATE Person p
 *      SET p.fname = fname,
 *          p.lname = lname
 *    WHERE p.id = id;
 *
 *    SET rows_updated = ROW_COUNT();
 *
 *    IF rows_updated > 0 THEN
 *       CALL App_Person_List(id);
 *    END IF;
 * 
 * END $$
 * ~~~
 *
 * NOTE: 
 */
